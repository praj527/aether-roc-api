// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.7.0 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	externalRef0 "github.com/onosproject/aether-roc-api/pkg/aether_2_0_0/types"
	externalRef1 "github.com/onosproject/aether-roc-api/pkg/aether_4_0_0/types"
)

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	pathPrefix := path.Dir(pathToFile)

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(pathPrefix, "./aether-2.0.0-openapi3.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef1.PathToRawSpec(path.Join(pathPrefix, "./aether-4.0.0-openapi3.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
